# GEMINI.md: AI駆動開発のための指示書

このドキュメントは、AIアシスタント（Gemini）が本プロジェクトにおいて開発タスクを遂行するための指示書です。一貫性、品質、効率性を担保するため、以下のガイドラインに厳密に従ってください。

## 1. 本ドキュメント(GEMINI.md)の運用指針

### 1.1. 目的
このドキュメントは、AIが自律的に開発を進めるための「思考と行動の起点」です。AIへの指示はすべてここに集約され、プロジェクトの憲法として機能します。

### 1.2. 構成と記述ルール
本ドキュメントの肥大化を防ぎ、可読性とメンテナンス性を維持するため、以下のルールに従って記述します。

*   **戦略とワークフローの明確な分離:**
    *   **戦略セクション (3章):** プロジェクトが **「何を (What)」** 目指し、 **「なぜ (Why)」** そうするのかという **方針** のみを記述します。長期的で普遍的な指針が対象です。
    *   **ワークフローセクション (4章):** 戦略を実現するために **「どのように (How)」** 作業するのかという、**具体的で再現可能な手順** のみを記述します。AIが直接実行・参照するコマンドや規約が対象です。
*   **詳細の外部化:**
    *   特定の技術に関する詳細なセットアップ手順、設計思想、長文の規約などは、`docs/`ディレクトリ配下に別のMarkdownファイルとして作成します。
    *   本ドキュメントには、その外部ファイルへの参照（リンク）を記述するに留め、本文書はAIの行動を規定する「指示」に特化させます。

### 1.3. 更新プロセス
本ドキュメントの変更は、品質を維持し、意図しない変更を防ぐため、以下のプロセスを必須とします。
1.  GitHub Issueで変更を提案します。
2.  提案が承認された後、AIがこのドキュメントを更新するPull Requestを作成します。
3.  Pull Requestがレビューされ、マージされることで変更が確定します。

### 1.4. 記述スタイルガイド
本ドキュメントの可読性を維持するため、以下の記述スタイルに従います。

*   **箇条書き（リスト）の使用:**
    *   **目的:** 手順、チェックリスト、並列な選択肢など、順序や階層を持つ情報を記述する場合に使用します。
    *   **例:** 開発プロセスのステップ、セルフレビューの観点。

*   **表（テーブル）の使用:**
    *   **目的:** 複数の項目を、共通の属性で比較・対照する場合に使用します。情報の対応関係を明確に示したい場合に最適です。
    *   **例:** ラベル一覧とそれぞれの役割、コマンドのオプションと説明。

*   **文体:** AIへの指示であることが明確になるよう、敬体（です・ます調）ではなく、常体（だ・である調）または命令形で記述します。

---

## 2. AI連携における基本原則
*   **目的志向:** Issueに書かれた表面的な指示だけでなく、その背後にあるユーザーの最終的な目的を理解し、目標達成のために能動的に行動してください。
*   **規約の絶対遵守と自己検証:** `GEMINI.md`は、AIの思考と行動を規定する唯一の憲法であり、そのルールは絶対である。ファイル変更、コマンド実行、Issue/PR操作など、あらゆる行動の前に、その行動が`GEMINI.md`のワークフローと完全に一致しているか自己検証を義務付ける。少しでも矛盾や不確実性がある場合は、決して実行せず、まずユーザーに確認を求めること。
*   **透明性の確保:** ファイル変更やコマンド実行など、AIが行った操作はすべて明確に記録・報告してください。
*   **段階的な実行:** 大きな変更は小さなステップに分割し、重要な判断が必要な場面では必ずユーザーに確認を求めてください。

## 3. プロジェクト戦略
*(このセクションでは、プロジェクトが目指す「方針」のみを記述します)*

*   **開発戦略:** 
    *   **Issue駆動開発 (IDD) の徹底:** すべての開発タスクはGitHub Issueを起点とします。Issueで目的、仕様、計画を明確に合意形成してから実装に着手することで、手戻りを防ぎ、透明性を確保します。
    *   **テスト駆動開発 (TDD) の採用:** 新機能追加やリファクタリングの際は、まずテストケースを定義し、そのテストをパスする形で実装を進めることを原則とします。これにより、コードの品質と保守性を最優先します。
*   **ドキュメント戦略:**
    *   **目的:** ドキュメントは、単なる成果物ではなく、プロジェクトの知識を体系化し、未来の自分たちを含むすべての関係者のための「思考の補助線」として機能することを目指します。知識の属人化を防ぎ、新規参画者の学習コストを下げ、円滑な意思決定を促進します。
    *   **原則: Documentation as Code (DaC):** コードと同じように、ドキュメントもバージョン管理され、レビュープロセスを経て、継続的に更新されるべきものとして扱います。コードの変更とドキュメントの変更は、常に一体として扱います。
*   **GitHub運用戦略:**
    *   **基本戦略: GitHub Flowの採用:** `main`ブランチを常にデプロイ可能な状態に保ち、機能追加や修正はすべてフィーチャーブランチで行う「GitHub Flow」を基本戦略とします。
    *   **採用理由:** この戦略は、運用ルールがシンプルで、AIがタスクを遂行する上でコンテキストの消費を抑え、セッションが中断された場合でも状態の把握が容易であるためです。複数の永続的なブランチ（例: `develop`）を管理する複雑さを回避し、AIが一貫性を保ち、安定して動作することを最優先します。
    *   **ブランチ戦略:**
        * `main`ブランチ: 本番環境にデプロイされる、最も安定したブランチです。直接のコミットは禁止し、Pull Requestのマージによってのみ更新されます。
        * フィーチャーブランチ: 各Issueに対応するブランチです。`main`ブランチから作成し、作業完了後に`main`ブランチへのPull Requestを作成します。
    *   **ブランチのライフサイクル:**
        * **作成:** Issueの実装に着手するタイミングで、`main`ブランチから作成します。
        * **命名規則:** `4.2. Issue駆動開発プロセス`で定義された `{issue番号}-{issueのタイトルをケバブケースにしたもの}` に従います。
        * **削除:** Pull Requestが`main`ブランチにマージされた後、速やかに削除します。

## 4. 開発ワークフロー
*(このセクションでは、戦略を実行するための「具体的で再現可能な手順」のみを記述します。AIはこのワークフローに厳密に従って、自律的に開発を遂行します)*

### 4.1. 基本原則：シングルタスクの徹底
AIは、複数のIssueを同時に処理しません。必ず一つのIssueが完了（マージ）してから、次のIssueに着手します。これにより、ブランチのコンフリクトや作業の混乱を防ぎます。

### 4.2. Issue駆動開発プロセス
以下は、一つのIssueが起票されてからクローズされるまでの一連のプロセスです。AIとユーザーはこのプロセスに従って連携します。

#### **ステップ1: Issueの受付と担当設定**
1.  **トリガー:** ユーザーまたはAIが新しいIssueを作成します。
2.  **AIの対応:**
    *   AIは新しく作成されたIssueを検知し、自身をそのIssueの担当者（Assignee）として設定します。
    *   Issueの内容を分析し、`4.4. ラベル管理`で定義された**状態ラベル**と**種別ラベル**の中から、最も適切と思われるラベルを付与します。
        *   **状態ラベル:** `status: planning`
        *   **種別ラベル:** `type: feature` や `type: bug` などから1つを選択

#### **ステップ2: 実装計画の策定と合意形成**
1.  **トリガー:** Issueに `status: planning` ラベルが付与される。
2.  **AIの対応:**
    *   Issueの内容、関連コメント、リンク先のドキュメントを精読し、表面的な要求だけでなく、その背後にある**目的**と**解決すべき根本的な課題**を完全に理解します。
    *   目的が不明確、または複数の解釈が可能な場合は、ユーザーに質問を投げかけ、意図を明確化します。
    *   複数の実装アプローチが考えられる場合は、それぞれのメリット・デメリットを簡潔に提示し、ユーザーに最適な選択を促します。
    *   上記の分析に基づき、**3章で定義されたドキュメント戦略**に照らして、実装や仕様変更に伴って更新が必要なドキュメントとコードを特定します。
    *   実現に必要なタスク（コード変更、ドキュメント更新など）を分解し、変更予定のファイルをすべてリストアップした、具体的な実装計画を立てます。
    *   以下のフォーマットで、実装計画をIssueにコメントします。その際、本文の長短に関わらず、必ず一時ファイルを作成し`--body-file`オプションを使用します。
        ```markdown
        ### 実装計画のご提案

        このIssueを解決するため、以下の計画で実装を進めます。

        **変更対象ファイル:**
        - `docs/01_ARCHITECTURE.md`
        - `src/core/main.py`
        - `tests/test_main.py`

        #### 1. **(ドキュメント更新の概要)**
        - `docs/01_ARCHITECTURE.md`: (更新内容の要約)

        #### 2. **(コード変更の概要)**
        - `src/core/main.py`: (具体的な作業内容 a)
        - `tests/test_main.py`: (具体的な作業内容 b)

        ---
        ご承認いただける場合は、このコメントに「承認」と返信してください。
        ```
3.  **ユーザーの対応:**
    *   計画をレビューし、問題がなければ「承認」とコメントします。修正が必要な場合は、具体的な修正点を指示します。

#### **ステップ3: 実装とPull Requestの作成**
1.  **トリガー:** ユーザーが実装計画を「承認」する。
2.  **AIの対応:**
    *   Issueの `status: planning` ラベルを削除し、`status: implementing` ラベルを付与します。
    *   `main` ブランチから、`{issue番号}-{issueのタイトルをケバブケースにしたもの}` という命名規則で新しいブランチを作成します。
        *   例: `12-update-development-workflow`
    *   実装計画に沿って、コードの変更、ファイルの作成・編集、テストの追加などを行います。
        *   **【重要】計画外のファイル変更の原則禁止:** AIは、実装計画で合意されたファイル以外は原則として変更しません。もし実装の過程で、計画外のファイル変更が必要だと判断した場合は、作業を中断し、その理由と変更内容をユーザーに報告し、承認を求めます。
    *   作業が完了したら、変更内容をコミットします。コミットメッセージは [Conventional Commits](https://www.conventionalcommits.org/) の規約に従います。
    *   `main` ブランチをターゲットにしたPull Requestを作成します。
    *   PRの本文には、関連するIssueへのリンク（例: `Closes #12`）を必ず含めます。

#### **ステップ4: セルフレビュー、自己修正、そしてレビュー依頼**
1.  **トリガー:** Pull Requestが作成される。
2.  **AIの対応:**
    *   Issueの `status: implementing` ラベルを削除し、`status: review` ラベルを付与します。
    *   **差分確認:** AIは `gh pr diff` コマンドを実行し、自身の変更内容が意図通りであることを確認します。
    *   **セルフレビューの実施:** 以下の観点でセルフレビューを実施します。
        1.  **差分は意図通りか？:** `gh pr diff` の結果と実装計画を照合します。
        2.  **実装はIssueの要求を満たしているか？**
        3.  **`GEMINI.md`の規約（テスト、命名規則など）を遵守しているか？**
        4.  **コードは十分に読みやすく、保守性が高いか？**
        5.  **変更による潜在的な副作用はないか？**
        6.  **計画外のファイル変更はないか？**
        7.  **ドキュメント更新は適切か？:** **ドキュメント戦略**および`5.1`の定義に照らして、ドキュメントの更新は適切か？
    *   **自己修正:**
        *   セルフレビューで問題を検知した場合、AIはまず自己修正を試みます。ローカルでコードを修正し、`git commit --amend` でコミットを修正後、`git push --force` でリモートブランチを更新します。
        *   修正後、再度このステップの最初（差分確認）からプロセスをやり直します。
        *   AI自身での修正が困難な場合に限り、ユーザーにメンションし、具体的な問題点と解決策の相談をPRのコメントで行います。
    *   **レビュー依頼:** 自己修正が不要、または完了した場合、以下のフォーマットでセルフレビューの結果をPRにコメントし、ユーザーにレビューを依頼します。その際、本文の長短に関わらず、必ず一時ファイルを作成し`--body-file`オプションを使用します。
        ```markdown
        ### セルフレビュー報告

        以下の観点でセルフレビューを実施し、問題がないことを確認しました。

        - **[観点1] 差分は意図通りか？**
          - (確認結果と自己評価)
        - **[観点2] 実装はIssueの要求を満たしているか？**
          - (確認結果と自己評価)
        - **[観点3] `GEMINI.md`の規約（テスト、命名規則など）を遵守しているか？**
          - (確認結果と自己評価)
        - **[観点4] コードは十分に読みやすく、保守性が高いか？**
          - (確認結果と自己評価)
        - **[観点5] 変更による潜在的な副作用はないか？**
          - (確認結果と自己評価)
        - **[観点6] 計画外のファイル変更はないか？**
          - (確認結果と自己評価)
        - **[観点7] コード変更に伴うドキュメント更新は適切か？**
          - (確認結果と自己評価)

        ---
        ご確認の上、マージのご承認をお願いいたします。
        ```
3.  **ユーザーの対応:**
    *   PRの内容とAIのセルフレビューをレビューします。
    *   問題がなければ、PRに対して「マージを承認します」とコメントします。修正が必要な場合は、具体的な修正点を指示します。

#### **ステップ5: マージとクリーンアップ**
1.  **トリガー:** ユーザーがPull Requestに「マージを承認します」とコメントする。
2.  **AIの対応:**
    *   Pull Requestをマージします。
    *   作業ブランチを削除します。
    *   関連するIssueが自動でクローズされたことを確認します。（PRの `Closes #12` により自動化）
    *   クローズされたIssueの `status: review` ラベルを削除し、`status: done` ラベルを付与します。

### 4.3. テストワークフロー
*   **テストの目的:** AIが生成するコードの品質を保証し、リファクタリングや機能追加に対する安全性を確保することを目的とします。
*   **テストの種類:**
    *   **単体テスト:** 個々の機能やモジュールが期待通りに動作することを検証します。
    *   **結合テスト:** 複数のモジュールを組み合わせた際に、連携が正しく行われることを検証します。
    *   **パフォーマンステスト:** 必要に応じて、システムの性能要件（応答時間、スループットなど）を測定するためのテストを実装します。
*   **テストカバレッジ:** 主要な機能やロジックについては、高いテストカバレッジを目指しますが、カバレッジの数値自体を目的とはしません。重要なのは、ビジネスロジックの核心部分が十分にテストされていることです。
*   **テスト実行:**
    *   **ローカルでの実行:** AIはコード変更後、関連するテストを実行し、すべてのテストがパスすることを確認してからPull Requestを作成します。
    *   **CIでの実行（推奨）:** Pull Requestが作成・更新されるたびに、すべてのテストが自動的に実行される体制を推奨します。CI環境が利用可能な場合、AIは積極的にその設定と活用を試みます。

### 4.4. ラベル管理
AIは、IssueやPull Requestの状況と種類を明確にするため、以下のラベルを使用します。
AIは、ラベルを付与する際に該当のラベルが存在しない場合、以下の定義に従って自動でラベルを作成した上で付与します。

#### **状態ラベル (Status)**
IssueやPRが現在どの開発段階にあるかを示します。

| ラベル名 | 色 | 説明 |
| :--- | :--- | :--- |
| `status: planning` | `#FBCA04` | AIが実装計画を策定中の状態 |
| `status: implementing` | `#1D76DB` | AIが実装作業中の状態 |
| `status: review` | `#8E44AD` | Pull Requestがレビュー待ちの状態 |
| `status: done` | `#0E8A16` | Issueの対応が完了し、マージ済みの状態 |

#### **種別ラベル (Type)**
IssueやPRがどのような種類のタスクであるかを示します。

| ラベル名 | 色 | 説明 |
| :--- | :--- | :--- |
| `type: bug` | `#D73A4A` | 既存機能の不具合 |
| `type: feature` | `#0E8A16` | 新しい機能の追加 |
| `type: documentation` | `#0075CA` | ドキュメントの作成・更新 |
| `type: refactor` | `#A2EEEF` | 外部的な振る舞いを変更しないコード改善 |
| `type: chore` | `#FFFFFF` | ビルドプロセスや補助ツールの変更など、上記以外のタスク |

## 5. ドキュメント戦略とワークフロー
AIがプロジェクトの仕様や設計思想を正確に理解し、開発とドキュメントの整合性を維持するためのワークフローを定義します。

### 5.1. ドキュメントの構成と記載内容
プロジェクトに関する情報は、`README.md`および`docs/`ディレクトリ配下のファイル群で管理します。AIは開発に着手する前に、必ずこれらのドキュメントに目を通し、内容を理解します。各ドキュメントの目的と記載すべき内容は以下の通りです。

| ファイル名 | 目的と記載すべき主要項目 | 更新タイミング |
| :--- | :--- | :--- |
| `README.md` | **プロジェクトの顔**として、新規参画者や外部の閲覧者が最初に目にする情報を提供します。<br><ul><li>**プロジェクト名と概要:** 何のプロジェクトか、何を解決するのかを簡潔に説明する。</li><li>**主な特徴:** 主要な機能や技術的なハイライトを箇条書きで示す。</li><li>**利用技術:** 使用している主要な言語、フレームワーク、ライブラリを列挙する。</li><li>**インストールとセットアップ:** プロジェクトをローカルで動かすための最小限の手順を記述する (`docs/04_SETUP.md`へのリンクを推奨)。</li><li>**基本的な使い方:** 主要な機能の簡単な利用例やコマンドを記載する。</li><li>**ライセンス:** プロジェクトのライセンスを明記する (`LICENSE`ファイルへのリンク)。</li><li>**貢献方法:** Issueの起票やPull Requestの作成方法など、貢献に関する基本的なガイドラインを示す。</li></ul> | プロジェクトの基本情報、技術スタック、セットアップ方法に大きな変更があった場合。 |
| `docs/00_PROJECT_OVERVIEW.md` | **プロジェクトの全体像**を定義し、関係者間の共通認識を形成します。<br><ul><li>**背景と課題:** このプロジェクトが生まれた経緯と、解決しようとしている具体的な課題を説明する。</li><li>**目的とゴール:** プロジェクトが目指す状態と、達成すべき具体的な目標（SMART原則など）を定義する。</li><li>**ターゲットユーザー:** このプロジェクトが誰のためのものかを明確にする。</li><li>**スコープ:** プロジェクトが「やること」と「やらないこと」の境界線を定義する。</li><li>**主要な機能一覧:** プロジェクトが提供する主要な機能をリストアップし、それぞれを簡潔に説明する。</li></ul> | プロジェクトの目的、スコープ、主要機能など、根幹に関わる仕様変更があった場合。 |
| `docs/01_ARCHITECTURE.md` | **システムの構造と設計思想**を定義し、技術的な意思決定の根拠を記録します。<br><ul><li>**アーキテクチャ概要:** システム全体の構成図（C4モデルなど）を用いて、コンポーネント間の関係性を示す。</li><li>**設計原則:** 採用した設計思想（例: クリーンアーキテクチャ、マイクロサービス）と、その選定理由を説明する。</li><li>**主要コンポーネントの詳細:** 各コンポーネントの責務、インターフェース、内部構造などを詳細に記述する。</li><li>**データモデル:** 主要なエンティティとそれらの関連性を示すER図など。</li><li>**インフラストラクチャ:** 本番環境・開発環境の構成、利用するクラウドサービスなどを記述する。</li><li>**技術選定の理由:** 特定の技術（言語、DB、フレームワーク）を選定した理由と、比較検討した他の選択肢を記録する。</li></ul> | 新しいコンポーネントの追加、既存コンポーネントの責務変更、インフラ構成の変更など、システムの構造に関わる変更があった場合。 |
| `docs/02_CODING_STANDARDS.md` | **コードの一貫性**を保つための規約を定義します。<br><ul><li>**フォーマット規約:** LinterやFormatter（例: Black, Prettier, ESLint）の設定と、その実行方法を明記する。</li><li>**命名規則:** 変数、関数、クラス、ファイル名などの命名規則を具体的に定義する。</li><li>**コーディングスタイル:** コメントの書き方、エラーハンドリングの方針、非同期処理の扱いなど、具体的なコーディング上のルールを定める。</li><li>**ライブラリ利用規約:** 標準ライブラリと外部ライブラリの使い分け方針や、利用を推奨／禁止するライブラリなどを定義する。</li><li>**非推奨パターン:** アンチパターンや、避けるべきコードの具体例を提示する。</li></ul> | 新しい規約の追加、既存規約の変更、利用するLinterの変更などがあった場合。 |
| `docs/03_TESTING_GUIDELINES.md` | **品質を保証**するためのテスト方針と手順を定義します。<br><ul><li>**テスト戦略:** 単体テスト、結合テスト、E2Eテストの役割分担と、それぞれのテストで何を保証するのかを定義する。</li><li>**テストの書き方:** テストコードの構成、命名規則、アサーションの書き方など、具体的な実装ルールを定める。</li><li>**テスト対象範囲:** どのコードにテストを書くべきか、また、カバレッジの目標値を定める（もしあれば）。</li><li>**テストの実行方法:** ローカル環境およびCI環境でのテスト実行コマンドと手順を明記する。</li><li>**モック/スタブの利用方針:** モックやスタブの使い分け、利用するライブラリなどを定義する。</li></ul> | テスト戦略の変更、新しいテストフレームワークの導入、テストの実行方法が変更された場合。 |
| `docs/04_SETUP.md` | **開発環境の構築手順**を詳細に定義します。<br><ul><li>**前提条件:** 必要なOS、言語のバージョン、パッケージマネージャ（npm, pipなど）を明記する。</li><li>**インストール手順:** リポジトリのクローンから、依存関係のインストールまでをステップバイステップで記述する。</li><li>**環境変数の設定:** 必要な環境変数の一覧と、その設定方法（`.env.example`など）を説明する。</li><li>**アプリケーションの起動:** 開発サーバーの起動コマンドや、動作確認の方法を記述する。</li><li>**トラブルシューティング:** よくあるエラーとその解決策をQ&A形式でまとめる。</li></ul> | 開発環境の構築手順や、必要なツール、環境変数に変更があった場合。 |

### 5.2. ドキュメントの更新プロセス
*   **原則:** 3章で定義した**ドキュメント戦略**、特に**Documentation as Code (DaC)**の原則に基づき、コードの変更とドキュメントの更新は常に一つのアトミックなタスクとして扱います。実装や仕様変更によって、`5.1`で定義されたいずれかのドキュメントの内容に影響が出る場合は、必ず対応するドキュメントを更新するPull Requestを作成します。
*   **手順:**
    1.  AIは、`ステップ2: 実装計画の策定と合意形成`の段階で、コード変更に伴って更新が必要なドキュメントを特定し、その更新内容を実装計画に含めます。
    2.  ユーザーの承認後、AIはコードの変更と合わせてドキュメントの更新も行います。
    3.  Pull Requestのレビューでは、コードの正しさと同様に、ドキュメントの記述が適切かどうかもレビューの対象となります。

### 5.3. 仕様・設計のドキュメント化支援ワークフロー
AIは、コード実装の前提となる仕様や設計がドキュメントに不足していると判断した場合、以下の対話型ワークフローを通じて、その明確化とドキュメント化を能動的に支援します。

1.  **トリガー（情報の不在検知）**
    *   AIはIssue対応の際、実装に着手するために不可欠な設計情報（例: 新機能の具体的な仕様、複雑なビジネスロジックのフロー、APIのエンドポイント詳細など）が、既存のドキュメントに明記されていないと判断した場合に、このワークフローを開始します。

2.  **ステップ1: ドキュメント化の提案**
    *   AIは実装作業を一旦保留し、「〇〇機能の実装に着手する前に、その仕様と設計を`docs/01_ARCHITECTURE.md`などにドキュメント化しませんか？これにより、手戻りを防ぎ、今後の開発効率も向上します。」といった形で、ドキュメント化のメリットを添えてユーザーに提案します。

3.  **ステップ2: 機能要件のヒアリング**
    *   ユーザーが同意した場合、AIは実装に必要な機能要件、制約事項、期待される動作などについて、ユーザーにヒアリングを行います。

4.  **ステップ3: AIによる設計案の提示**
    *   ヒアリングした要件に基づき、AIが具体的な設計案を作成して提示します。提示する設計案には、以下のような内容が含まれます。
        *   関連するアーキテクチャ図の更新案
        *   処理の流れを示すシーケンス図やフローチャート
        *   データベースのテーブル設計やER図
        *   APIのエンドポイント設計（リクエスト、レスポンスの形式など）

5.  **ステップ4: 合意形成とIssue起票提案**
    *   ユーザーが提示された設計案をレビューし、承認します。修正が必要な場合は、対話を通じて設計を洗練させます。
    *   設計が固まったら、AIはその設計内容をドキュメントに反映させるための、新しい`type: documentation`のIssueを作成することをユーザーに提案します。
    *   この提案が承認されれば、AIは新しいIssueを作成し、通常の`4.2 Issue駆動開発プロセス`に従ってドキュメントの更新作業を行います。これにより、実装と設計の同期が保たれます。